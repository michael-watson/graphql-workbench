# GraphQL Schema Design Best Practices

A compilation of schema design best practices drawing from Apollo GraphQL's official guidance, Michael Watson's work on federated schema design, and the broader GraphQL community.

---

## Table of Contents

- [Demand-Oriented Schema Design](#demand-oriented-schema-design)
- [Federated Schema Design](#federated-schema-design)
- [Naming Conventions](#naming-conventions)
- [Query Design](#query-design)
- [Mutation Design](#mutation-design)
- [Schema Expressiveness and Documentation](#schema-expressiveness-and-documentation)
- [Schema Stewardship](#schema-stewardship)
- [Performance Considerations](#performance-considerations)
- [Anti-Patterns to Avoid](#anti-patterns-to-avoid)
- [Sources](#sources)

---

## Demand-Oriented Schema Design

The central principle of GraphQL schema design is that a schema should be designed around the needs of the clients consuming it, not the shape of the underlying data sources.

### Design for Client Needs, Not Data Sources

A schema should represent product functions and domain boundaries rather than mirroring databases, REST endpoints, or microservice contracts. How data is stored is often shaped very differently than what clients actually need.

> A schema should not be tightly coupled to any particular client, nor should it expose implementation details of any particular service.
> — [Principled GraphQL](https://principledgraphql.com/)

### Avoid Single-Client Over-Optimization

Consult multiple client teams early and continuously. Aggregate feedback across different consumers rather than designing for one specific application's needs. The schema should serve as a reusable platform across all clients.

### Treat Your Schema as a Platform

Expose consistent capabilities rather than creating client-specific variants. For example, expose a single `checkoutCart` mutation rather than creating separate "web" and "mobile" variants. Designing client-specific type variants is an anti-pattern.

---

## Federated Schema Design

The following principles are drawn from [Michael Watson's blog post on federated schema design](https://www.apollographql.com/blog/federated-schema-design) and his work as a Developer Advocate at Apollo GraphQL, including his [Demand-Driven Schema Design workshop at GraphQLConf 2024](https://graphql.org/conf/2024/schedule/a9ad5f1632866787f2ae33020dbe8e77/?name=Workshop:+Demand-Driven+Schema+Design).

### Think in Entities

Entities form the foundation of federated design. They are identified by the `@key` directive and represent uniquely identifiable objects that map closely to data sources. To identify entities, ask:

- Can you uniquely identify objects based on one or more fields?
- Does the type map closely to your data source shape?
- Are inputs to resolve the entity well-defined?

```graphql
type Product @key(fields: "id") {
  id: ID!
  name: String!
  price: Float!
}
```

### Use Domain-Oriented Thinking

Align subgraphs with business subdomains rather than technical concerns like "web" vs. "mobile." Use consistent language within each domain and establish naming conventions that apply across the entire supergraph.

### Make Your Collaboration Strategy Explicit

Choose between two approaches based on your organization's needs:

- **Single subgraph ownership** — One subgraph owns a type; others extend it. Suited for small or greenfield projects.
- **Shared type ownership** — Multiple subgraphs can provide fields for entities. Necessary for enterprises with existing SLAs and multiple teams.

### Use Subgraph-Focused Workflows

Teams should not need to spin up unrelated subgraphs to develop features. Support schema-first or code-first approaches while avoiding autogenerated schemas that often include unnecessary fields.

### Hide Implementation Details

Replace foreign key-like fields with entity references that leverage federation:

```graphql
# Anti-pattern (REST-influenced)
type Review {
  id: ID!
  productID: ID  # Exposes implementation detail
}

# Better (federation-enabled)
type Review {
  id: ID!
  product: Product  # Connects the graph
}
```

---

## Naming Conventions

Consistency in naming is critical, especially when composing schemas from multiple subgraphs into a single federated GraphQL API.

### Fields: camelCase

Field names should use `camelCase`, matching the conventions of most GraphQL client languages (JavaScript, Java, Kotlin, Swift).

```graphql
type User {
  firstName: String!    # correct
  lastName: String!     # correct
  First_Name: String!   # incorrect
}
```

### Types: PascalCase

Type names should use `PascalCase`, matching how classes are defined in those same languages. Avoid prefixes/suffixes like `Type`, `Object`, or `Interface`.

```graphql
type ShippingAddress { ... }  # correct
type shippingAddress { ... }  # incorrect
type ShippingAddressType { ... }  # incorrect — avoid "Type" suffix
```

### Enums: PascalCase Names, SCREAMING_SNAKE_CASE Values

Enum type names should use `PascalCase`. Enum values should use `SCREAMING_SNAKE_CASE` since they are similar to constants.

```graphql
enum OrderStatus {
  PENDING
  IN_PROGRESS
  SHIPPED
  DELIVERED
}
```

### Input Types: End with "Input"

Input types should be named with an `Input` suffix to distinguish them from output types.

```graphql
input CreateProductInput {
  name: String!
  price: Float!
  categoryId: ID!
}
```

### Arguments: camelCase

Argument names should follow the same `camelCase` convention as field names.

### Directives: camelCase

Custom directive names should use `camelCase`.

```graphql
directive @cacheControl(maxAge: Int) on FIELD_DEFINITION
```

### Cross-Subgraph Consistency

Having a `users` query in one service and a `getProducts` query in another breaks predictability. Establish and enforce naming patterns that span the entire supergraph.

---

## Query Design

### Design Finer-Grained Queries

Create purpose-driven queries aligned with specific use cases rather than generic multi-purpose queries with nullable arguments:

```graphql
# Preferred — clear intent
type Query {
  userById(id: ID!): User
  userByUsername(username: String!): User
  userByEmail(email: String!): User
}

# Avoid — ambiguous, requires runtime validation
type Query {
  user(id: ID, username: String, email: String): User
}
```

### Add Pagination Only When Necessary

Not every list field needs pagination. When you do add it, standardize the implementation style across your graph (e.g., always use cursor-based pagination) and enforce the convention.

```graphql
type Query {
  """Fetch a paginated list of products based on a filter."""
  products(
    "How many products per page."
    first: Int = 5
    "Begin paginating after this cursor."
    after: String
  ): ProductConnection
}
```

---

## Mutation Design

### Return Specific Payload Types

All mutations should return a payload output object specific to that mutation:

```graphql
type Mutation {
  registerUser(input: RegisterUserInput!): RegisterUserPayload!
}

type RegisterUserPayload {
  user: User!
  token: String!
}
```

### Design Single-Purpose Mutations

Create separate mutations for independent operations rather than a single generic update mutation:

```graphql
# Preferred — clear, single-purpose mutations
type Mutation {
  updateFullName(name: String!): UpdateFullNamePayload!
  addSecondaryEmail(email: String!): AddSecondaryEmailPayload!
  changeBillingAddress(address: AddressInput!): ChangeBillingAddressPayload!
}

# Avoid — generic, multi-purpose mutation
type Mutation {
  updateAccount(input: UpdateAccountInput!): Account
}
```

### Reflect Client Intent in Mutation Names

Mutation names should describe the action from the client's perspective, not mirror HTTP methods:

```graphql
# Preferred
createProduct(input: CreateProductInput!): CreateProductPayload!
updateProductName(id: ID!, name: String!): UpdateProductNamePayload!

# Avoid — REST verb patterns
postProduct(input: ProductInput!): Product
patchProduct(id: ID!, input: ProductInput!): Product
```

---

## Schema Expressiveness and Documentation

A good schema conveys meaning about the underlying nodes in a graph and the relationships between them. Documentation is a core dimension of schema expressiveness.

### Document Everything in SDL

All types, fields, and arguments should include descriptions unless entirely self-evident:

```graphql
"""
A product available in the catalog.
Products can belong to one or more categories
and may have associated reviews.
"""
type Product {
  "Unique identifier for the product."
  id: ID!

  "Human-readable product name displayed to customers."
  name: String!

  """
  Current price in the store's base currency.
  Always reflects any active promotions.
  """
  price: Float!

  "Category this product belongs to."
  category: Category!

  """
  Reviews submitted by verified purchasers.
  Returns most recent reviews first.
  """
  reviews(
    "Maximum number of reviews to return."
    first: Int = 10
  ): [Review!]!
}
```

### Let the Schema Enforce Constraints

Avoid generic fields and runtime logic when the schema itself can enforce constraints. Use non-null types, enums, and specific input types to make invalid states unrepresentable.

---

## Schema Stewardship

Schema stewardship — the ongoing process of guiding schema evolution across teams — is as important as the initial design. These practices are drawn from Apollo GraphQL's [10 Best Practices for Schema Stewardship](https://www.apollographql.com/blog/10-best-practices-for-schema-stewardship).

### 1. Adopt a Stewardship Mindset

Stewardship emphasizes collaborative tending — guiding rather than dictating. This is more effective than rules-based governance for building consensus around shared schemas across multiple teams.

### 2. Understand All Teams, Motivations, and Struggles

Different teams bring distinct perspectives:

- **App teams** seek schemas delivering complete functionality for user experiences
- **Graph teams** pursue unified, optimal designs
- **Service teams** want isolation from client-side complexities

Understanding these motivations creates the trust necessary for change.

### 3. Assume Good Intent

Celebrate progress and focus on benefits rather than criticizing old approaches. Invitation and encouragement outperform criticism when driving schema adoption.

### 4. Lean Into the Friction

Acknowledge pain points and missing alignment. Without consensus objectives, teams pursue self-interest, creating siloed graphs and duplicated patterns.

### 5. Adopt a Client-Centric Mindset

Schema fitness is measured by client utility, not abstract purity. Schema designers should prioritize what client applications require over theoretical elegance.

### 6. Keep Iterating Your Organizing Model

No single organizing model remains optimal permanently. Reflect on friction points and iterate between models:

- **Siloed** — Teams adopt GraphQL independently (quick starts, but disconnected)
- **Graph Guild** — Community of experts sharing best practices (depends on volunteers)
- **Central Graph Team** — Dedicated platform team (concentrates expertise, but bottlenecks)
- **Hybrid** — Central team partners with embedded local experts (scales best)

### 7. Scale Reviews with Async Processes and Schema Tools

- Conduct async reviews of schema proposals across time zones
- Include full use cases and UI screenshots in proposals for context
- Integrate automated schema checks and linting into CI/CD pipelines

### 8. Pay Special Attention to Teams' First Schema Review

Communicate the schema style guide and the reasoning behind its guidelines. Make initial reviews mandatory to establish alignment, then allow subsequent reviews to be optional.

### 9. Adopt a Product Mindset

Treat the unified graph schema like a product with customers, a roadmap, and success criteria. This elevates the graph from an infrastructure concern to a strategic asset.

### 10. Keep Moving Forward

Paradigm shifts succeed through iterative approaches. Route around obstacles, find allies, and seek community support.

---

## Performance Considerations

### Use Persisted Queries

Automatic persisted queries (APQ) reduce bandwidth by sending SHA-256 hashes of queries instead of full query strings, improving both performance and security.

### Batch and Cache Strategically

Batching merges multiple queries into a single request, reducing network round trips. Caching at the resolver and response levels mitigates the N+1 query problem.

### Use Fragments for Reusability

Fragments provide reusable units of query logic shared across multiple operations, ensuring consistent data fetching patterns and reducing duplication.

```graphql
fragment ProductCard on Product {
  id
  name
  price
  imageUrl
}

query FeaturedProducts {
  featured {
    ...ProductCard
  }
}

query SearchResults($query: String!) {
  search(query: $query) {
    ...ProductCard
    description
  }
}
```

---

## Anti-Patterns to Avoid

| Anti-Pattern | Why It's Harmful | What to Do Instead |
|---|---|---|
| Auto-generating schemas from data sources | Exposes unnecessary fields, couples schema to storage | Design demand-oriented schemas manually |
| REST verb prefixes (`getUser`, `listProducts`) | Breaks GraphQL conventions, signals REST thinking | Use noun-based queries (`user`, `products`) |
| Foreign key fields (`productID: ID`) | Exposes implementation details | Use entity references (`product: Product`) |
| Client-specific types (`WebUser`, `MobileUser`) | Creates fragmentation, increases maintenance | Design generic types serving all clients |
| Generic multi-purpose mutations | Hard to validate, unclear intent | Create single-purpose mutations |
| `Type`/`Object`/`Interface` suffixes | Redundant — the SDL already conveys the kind | Use clean PascalCase names |

---

## Sources

- [Michael Watson — Federated Schema Design (Apollo GraphQL Blog)](https://www.apollographql.com/blog/federated-schema-design)
- [Michael Watson — Demand-Driven Schema Design Workshop (GraphQLConf 2024)](https://graphql.org/conf/2024/schedule/a9ad5f1632866787f2ae33020dbe8e77/?name=Workshop:+Demand-Driven+Schema+Design)
- [Apollo GraphQL — Demand Oriented Schema Design](https://www.apollographql.com/docs/graphos/schema-design/guides/demand-oriented-schema-design)
- [Apollo GraphQL — Enterprise Best Practices: Schema Design](https://www.apollographql.com/tutorials/schema-design-best-practices)
- [Apollo GraphQL — 10 Best Practices for Schema Stewardship (Part 1)](https://www.apollographql.com/blog/10-best-practices-for-schema-stewardship)
- [Apollo GraphQL — 10 Best Practices for Schema Stewardship (Part 2)](https://www.apollographql.com/blog/community/graphql-champions/10-best-practices-for-schema-stewardship-part-2-of-2/)
- [Apollo GraphQL — Schema Basics](https://www.apollographql.com/docs/apollo-server/schema/schema)
- [GraphQL.org — Best Practices](https://graphql.org/learn/best-practices/)
