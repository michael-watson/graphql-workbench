# GraphQL Schema Design Best Practices

A compilation of schema design best practices drawing from Apollo GraphQL's official guidance, Michael Watson's work on federated schema design, Yelp's internal GraphQL schema design and nullability guidelines, and the broader GraphQL community.

---

## Table of Contents

- [Demand-Oriented Schema Design](#demand-oriented-schema-design)
- [Federated Schema Design](#federated-schema-design)
- [Naming Conventions](#naming-conventions)
- [Query Design](#query-design)
- [Mutation Design](#mutation-design)
- [Type Design and Structure](#type-design-and-structure)
- [Nullability](#nullability)
- [Schema Expressiveness and Documentation](#schema-expressiveness-and-documentation)
- [Schema Stewardship](#schema-stewardship)
- [Performance Considerations](#performance-considerations)
- [Anti-Patterns to Avoid](#anti-patterns-to-avoid)
- [Sources](#sources)

---

## Demand-Oriented Schema Design

The central principle of GraphQL schema design is that a schema should be designed around the needs of the clients consuming it, not the shape of the underlying data sources.

### Design for Client Needs, Not Data Sources

A schema should represent product functions and domain boundaries rather than mirroring databases, REST endpoints, or microservice contracts. How data is stored is often shaped very differently than what clients actually need.

> A schema should not be tightly coupled to any particular client, nor should it expose implementation details of any particular service.
> — [Principled GraphQL](https://principledgraphql.com/)

### Avoid Single-Client Over-Optimization

Consult multiple client teams early and continuously. Aggregate feedback across different consumers rather than designing for one specific application's needs. The schema should serve as a reusable platform across all clients.

### Describe Data, Not Views

Focus schemas on underlying data structures rather than specific UI implementations. This ensures flexibility across different platforms and interfaces. Return domain types (e.g., `User`) for profile components instead of creating view-specific types like `ProfileCardData`.

### Treat Your Schema as a Platform

Expose consistent capabilities rather than creating client-specific variants. For example, expose a single `checkoutCart` mutation rather than creating separate "web" and "mobile" variants. Designing client-specific type variants is an anti-pattern.

---

## Federated Schema Design

The following principles are drawn from [Michael Watson's blog post on federated schema design](https://www.apollographql.com/blog/federated-schema-design) and his work as a Developer Advocate at Apollo GraphQL, including his [Demand-Driven Schema Design workshop at GraphQLConf 2024](https://graphql.org/conf/2024/schedule/a9ad5f1632866787f2ae33020dbe8e77/?name=Workshop:+Demand-Driven+Schema+Design).

### Think in Entities

Entities form the foundation of federated design. They are identified by the `@key` directive and represent uniquely identifiable objects that map closely to data sources. To identify entities, ask:

- Can you uniquely identify objects based on one or more fields?
- Does the type map closely to your data source shape?
- Are inputs to resolve the entity well-defined?

```graphql
type Product @key(fields: "id") {
  id: ID!
  name: String!
  price: Float!
}
```

### Use Domain-Oriented Thinking

Align subgraphs with business subdomains rather than technical concerns like "web" vs. "mobile." Use consistent language within each domain and establish naming conventions that apply across the entire supergraph.

### Make Your Collaboration Strategy Explicit

Choose between two approaches based on your organization's needs:

- **Single subgraph ownership** — One subgraph owns a type; others extend it. Suited for small or greenfield projects.
- **Shared type ownership** — Multiple subgraphs can provide fields for entities. Necessary for enterprises with existing SLAs and multiple teams.

### Use Subgraph-Focused Workflows

Teams should not need to spin up unrelated subgraphs to develop features. Support schema-first or code-first approaches while avoiding autogenerated schemas that often include unnecessary fields.

### Hide Implementation Details

Replace foreign key-like fields with entity references that leverage federation:

```graphql
# Anti-pattern (REST-influenced)
type Review {
  id: ID!
  productID: ID  # Exposes implementation detail
}

# Better (federation-enabled)
type Review {
  id: ID!
  product: Product  # Connects the graph
}
```

---

## Naming Conventions

Consistency in naming is critical, especially when composing schemas from multiple subgraphs into a single federated GraphQL API.

### Fields: camelCase

Field names should use `camelCase`, matching the conventions of most GraphQL client languages (JavaScript, Java, Kotlin, Swift).

```graphql
type User {
  firstName: String!    # correct
  lastName: String!     # correct
  First_Name: String!   # incorrect
}
```

### Types: PascalCase

Type names should use `PascalCase`, matching how classes are defined in those same languages. Avoid prefixes/suffixes like `Type`, `Object`, or `Interface`.

```graphql
type ShippingAddress { ... }  # correct
type shippingAddress { ... }  # incorrect
type ShippingAddressType { ... }  # incorrect — avoid "Type" suffix
```

### Be Specific When Naming Types

Use specific, namespaced type names to reduce ambiguity and naming collisions, especially in large schemas shared across teams. For example, prefer `BusinessCategory` over `Category` — generic names risk conflicting with types from other domains.

### Don't Namespace Fields

Fields are implicitly namespaced by their parent type, so avoid redundant prefixes in field names:

```graphql
type BusinessAddress {
  """
  Formatted address based on locale
  """
  formatted: String
}
```

Use `formatted`, not `formattedBusinessAddress`. The parent type already provides the context.

### Enums: PascalCase Names, SCREAMING_SNAKE_CASE Values

Enum type names should use `PascalCase`. Enum values should use `SCREAMING_SNAKE_CASE` since they are similar to constants.

```graphql
enum OrderStatus {
  PENDING
  IN_PROGRESS
  SHIPPED
  DELIVERED
}
```

### Input Types: End with "Input"

Input types should be named with an `Input` suffix to distinguish them from output types.

```graphql
input CreateProductInput {
  name: String!
  price: Float!
  categoryId: ID!
}
```

### Arguments: camelCase

Argument names should follow the same `camelCase` convention as field names.

### Directives: camelCase

Custom directive names should use `camelCase`.

```graphql
directive @cacheControl(maxAge: Int) on FIELD_DEFINITION
```

### Cross-Subgraph Consistency

Having a `users` query in one service and a `getProducts` query in another breaks predictability. Establish and enforce naming patterns that span the entire supergraph.

---

## Query Design

### Keep Top-Level Queries Minimal

Model data as a tree with core types as root nodes. Before adding new top-level queries, consider whether the data fits better as an attribute of an existing type. For example, add `claimability` as a `Business` attribute rather than `canClaimBusiness` as a root query.

### Design Finer-Grained Queries

Create purpose-driven queries aligned with specific use cases rather than generic multi-purpose queries with nullable arguments:

```graphql
# Preferred — clear intent
type Query {
  userById(id: ID!): User
  userByUsername(username: String!): User
  userByEmail(email: String!): User
}

# Avoid — ambiguous, requires runtime validation
type Query {
  user(id: ID, username: String, email: String): User
}
```

### Add Pagination Only When Necessary

Not every list field needs pagination. When you do add it, standardize the implementation style across your graph (e.g., always use cursor-based pagination) and enforce the convention.

```graphql
type Query {
  """Fetch a paginated list of products based on a filter."""
  products(
    "How many products per page."
    first: Int = 5
    "Begin paginating after this cursor."
    after: String
  ): ProductConnection
}
```

---

## Mutation Design

### Return Specific Payload Types

All mutations should return a payload output object specific to that mutation:

```graphql
type Mutation {
  registerUser(input: RegisterUserInput!): RegisterUserPayload!
}

type RegisterUserPayload {
  user: User!
  token: String!
}
```

### Design Single-Purpose Mutations

Create separate mutations for independent operations rather than a single generic update mutation:

```graphql
# Preferred — clear, single-purpose mutations
type Mutation {
  updateFullName(name: String!): UpdateFullNamePayload!
  addSecondaryEmail(email: String!): AddSecondaryEmailPayload!
  changeBillingAddress(address: AddressInput!): ChangeBillingAddressPayload!
}

# Avoid — generic, multi-purpose mutation
type Mutation {
  updateAccount(input: UpdateAccountInput!): Account
}
```

### Reflect Client Intent in Mutation Names

Mutation names should describe the action from the client's perspective, not mirror HTTP methods:

```graphql
# Preferred
createProduct(input: CreateProductInput!): CreateProductPayload!
updateProductName(id: ID!, name: String!): UpdateProductNamePayload!

# Avoid — REST verb patterns
postProduct(input: ProductInput!): Product
patchProduct(id: ID!, input: ProductInput!): Product
```

---

## Type Design and Structure

### Categorize Types by Scope

Types fall into two categories:

1. **Core types** — Widely used across teams (e.g., `Business`, `User`). These warrant higher scrutiny during code reviews and urgent triage for runtime issues.
2. **Domain-specific types** — Used by one or few components (e.g., `BusinessClaimability`). These have narrower impact and can tolerate more aggressive non-nullability.

### Use Existing Standardized Types and Scalars

Leverage standardized types for common concepts like photos, dates, and times to maintain consistency across the schema. Avoid encoding structured data as raw strings.

```graphql
type Review {
  uploadedPhoto: BusinessPhoto
  createdAt: DateTime
}
```

Not: `uploadedPhotoUrl: String` or `createdAt: String`

### Group Related Fields Together

Create nested types for related field groups to reduce bloat on core types and improve discoverability:

```graphql
type BusinessAdvertising {
  isAdvertiser: Boolean!
  clicks: Int!
  revenueFromCampaign: Float!
  keywords: [String!]!
}

extend type Business {
  advertising: BusinessAdvertising
}
```

Consider the "rule of three" — start with direct fields, then refactor into subgroups as complexity grows.

### Link via Types, Not IDs

Reference types directly rather than returning IDs, enabling flexible data fetching without additional queries:

```graphql
type Review {
  """
  The business this review is about
  """
  business: Business
}
```

Not: `businessId: Int`

---

## Nullability

Fields are nullable by default in GraphQL to support schema evolution and maintain backwards compatibility. Getting nullability right is important — nullable fields complicate client development by forcing explicit null handling, while overly aggressive non-nullability risks cascading failures when a non-nullable field resolves to null and GraphQL nullifies the entire parent object up the tree.

### Scalar Fields

Don't make scalar fields nullable when null makes no semantic sense. For example, a `Money` type requires both `value` and `currencyCode` to be meaningful — these should be non-nullable. However, fields that might plausibly become null in the future (like `location: Location`) should remain nullable.

```graphql
type Money {
  value: Int!
  currencyCode: String!
}
```

### Type Complexity and Usage

Larger, widely-used types should have more nullable fields. If a non-nullable field errors out, the entire type nullifies. Complex types are more likely to have edge cases where fields could plausibly be absent.

For example, making `headerPhoto: Photo!` non-nullable on `Business` risks nullifying the entire `Business` object if the photo resolver fails. A `Photo` type's own fields can more aggressively be non-nullable since losing one photo has less impact.

### Semantic Nulls and Type Design

When you frequently expect fields to be null in normal circumstances, consider using unions or interfaces to create distinct types. This improves self-documentation and reduces nullable fields.

```graphql
interface User {
  name: String!
  reviews: [Review!]!
}

type NormalUser implements User {
  name: String!
  reviews: [Review!]!
}

type EliteUser implements User {
  name: String!
  reviews: [Review!]!
  yearsElite: [Year!]!
}
```

### Lists

Lists should not be null, and their contents should not be null either. Return empty lists instead of null, and filter null items server-side.

```graphql
# Preferred
reviews: [Review!]!

# Avoid
reviews: [Review]
```

### Booleans

Booleans should not be nullable. Null doesn't clearly represent true or false. If a third state exists, use an enum instead.

```graphql
# Preferred
hasDelivery: Boolean!

# If a third state is needed, use an enum
enum DeliveryStatus {
  AVAILABLE
  UNAVAILABLE
  UNKNOWN
}
```

### Enums

Enums should not be nullable. Null states should be explicit enum values with descriptive names rather than null.

```graphql
enum ReviewState {
  REVIEWED
  DRAFT
  NONE
  ERROR
  NOT_APPLICABLE
}

type Business {
  reviewState: ReviewState!
}
```

### Strings

Prefer nullable strings over empty strings. Empty strings create confusing UI states. Use `caption: String` rather than `caption: String!` to force null-handling at the client level rather than relying on empty values to signal absence.

```graphql
# Preferred — nullable, forces client to handle absence explicitly
caption: String

# Avoid — non-nullable can lead to empty string confusion
caption: String!
```

---

## Schema Expressiveness and Documentation

A good schema conveys meaning about the underlying nodes in a graph and the relationships between them. Documentation is a core dimension of schema expressiveness.

### Use Triple Quotes for Descriptions

Use triple quotes (`"""`) for documentation, not hashtags (`#`). Triple quotes are parsed as descriptions and appear in introspection results and tooling; hashtags are ignored by the parser.

```graphql
extend type Business {
  """
  The business name (e.g., "The French Laundry")
  """
  name: String
}
```

### Space Out Field Descriptions

Add newlines between field descriptions for improved readability:

```graphql
type Banner {
  """
  Logo image URL
  """
  logoUrl: String

  """
  Heading starting portion
  """
  headingStart: String
}
```

### Document Everything in SDL

All types, fields, and arguments should include descriptions unless entirely self-evident:

```graphql
"""
A product available in the catalog.
Products can belong to one or more categories
and may have associated reviews.
"""
type Product {
  "Unique identifier for the product."
  id: ID!

  "Human-readable product name displayed to customers."
  name: String!

  """
  Current price in the store's base currency.
  Always reflects any active promotions.
  """
  price: Float!

  "Category this product belongs to."
  category: Category!

  """
  Reviews submitted by verified purchasers.
  Returns most recent reviews first.
  """
  reviews(
    "Maximum number of reviews to return."
    first: Int = 10
  ): [Review!]!
}
```

### Be Explicit with Descriptions

Provide comprehensive context using first-principles explanations. Avoid team-specific acronyms, describe all enum values, and link to source documentation. Frame descriptions so that a new team member with no prior context can understand the field:

```graphql
extend type Business {
  """
  Returns a list of Yelfies.

  A Yelfie is a user photo taken at a business with special filters.
  See y/yelfies for more information.
  """
  getYelfies(
    """
    Filter by Yelfie type (e.g., "smilingFace", "eatingFood").

    Defined in yelfie.json config — see y/yelfie-type-docs
    """
    yelfieType: String!
  ): [Yelfie]
}
```

### Let the Schema Enforce Constraints

Avoid generic fields and runtime logic when the schema itself can enforce constraints. Use non-null types, enums, and specific input types to make invalid states unrepresentable.

---

## Schema Stewardship

Schema stewardship — the ongoing process of guiding schema evolution across teams — is as important as the initial design. These practices are drawn from Apollo GraphQL's [10 Best Practices for Schema Stewardship](https://www.apollographql.com/blog/10-best-practices-for-schema-stewardship).

### 1. Adopt a Stewardship Mindset

Stewardship emphasizes collaborative tending — guiding rather than dictating. This is more effective than rules-based governance for building consensus around shared schemas across multiple teams.

### 2. Understand All Teams, Motivations, and Struggles

Different teams bring distinct perspectives:

- **App teams** seek schemas delivering complete functionality for user experiences
- **Graph teams** pursue unified, optimal designs
- **Service teams** want isolation from client-side complexities

Understanding these motivations creates the trust necessary for change.

### 3. Assume Good Intent

Celebrate progress and focus on benefits rather than criticizing old approaches. Invitation and encouragement outperform criticism when driving schema adoption.

### 4. Lean Into the Friction

Acknowledge pain points and missing alignment. Without consensus objectives, teams pursue self-interest, creating siloed graphs and duplicated patterns.

### 5. Adopt a Client-Centric Mindset

Schema fitness is measured by client utility, not abstract purity. Schema designers should prioritize what client applications require over theoretical elegance.

### 6. Keep Iterating Your Organizing Model

No single organizing model remains optimal permanently. Reflect on friction points and iterate between models:

- **Siloed** — Teams adopt GraphQL independently (quick starts, but disconnected)
- **Graph Guild** — Community of experts sharing best practices (depends on volunteers)
- **Central Graph Team** — Dedicated platform team (concentrates expertise, but bottlenecks)
- **Hybrid** — Central team partners with embedded local experts (scales best)

### 7. Scale Reviews with Async Processes and Schema Tools

- Conduct async reviews of schema proposals across time zones
- Include full use cases and UI screenshots in proposals for context
- Integrate automated schema checks and linting into CI/CD pipelines

### 8. Pay Special Attention to Teams' First Schema Review

Communicate the schema style guide and the reasoning behind its guidelines. Make initial reviews mandatory to establish alignment, then allow subsequent reviews to be optional.

### 9. Adopt a Product Mindset

Treat the unified graph schema like a product with customers, a roadmap, and success criteria. This elevates the graph from an infrastructure concern to a strategic asset.

### 10. Keep Moving Forward

Paradigm shifts succeed through iterative approaches. Route around obstacles, find allies, and seek community support.

---

## Performance Considerations

### Use Persisted Queries

Automatic persisted queries (APQ) reduce bandwidth by sending SHA-256 hashes of queries instead of full query strings, improving both performance and security.

### Batch and Cache Strategically

Batching merges multiple queries into a single request, reducing network round trips. Caching at the resolver and response levels mitigates the N+1 query problem.

### Use Fragments for Reusability

Fragments provide reusable units of query logic shared across multiple operations, ensuring consistent data fetching patterns and reducing duplication.

```graphql
fragment ProductCard on Product {
  id
  name
  price
  imageUrl
}

query FeaturedProducts {
  featured {
    ...ProductCard
  }
}

query SearchResults($query: String!) {
  search(query: $query) {
    ...ProductCard
    description
  }
}
```

---

## Anti-Patterns to Avoid

| Anti-Pattern | Why It's Harmful | What to Do Instead |
|---|---|---|
| Auto-generating schemas from data sources | Exposes unnecessary fields, couples schema to storage | Design demand-oriented schemas manually |
| REST verb prefixes (`getUser`, `listProducts`) | Breaks GraphQL conventions, signals REST thinking | Use noun-based queries (`user`, `products`) |
| Foreign key fields (`productID: ID`) | Exposes implementation details | Use entity references (`product: Product`) |
| Client-specific types (`WebUser`, `MobileUser`) | Creates fragmentation, increases maintenance | Design generic types serving all clients |
| Generic multi-purpose mutations | Hard to validate, unclear intent | Create single-purpose mutations |
| `Type`/`Object`/`Interface` suffixes | Redundant — the SDL already conveys the kind | Use clean PascalCase names |
| Nullable booleans and enums | Null doesn't represent true/false; hides a third state | Use non-nullable booleans or explicit enum values |
| Non-nullable strings defaulting to `""` | Empty strings create confusing UI states | Use nullable strings to signal absence |
| View-specific types (`ProfileCardData`) | Couples schema to UI, reduces reusability | Describe data, not views — return domain types |
| Hashtag comments (`#`) for documentation | Ignored by the parser, invisible in introspection | Use triple-quote descriptions (`"""`) |

---

## Sources

- [Michael Watson — Federated Schema Design (Apollo GraphQL Blog)](https://www.apollographql.com/blog/federated-schema-design)
- [Michael Watson — Demand-Driven Schema Design Workshop (GraphQLConf 2024)](https://graphql.org/conf/2024/schedule/a9ad5f1632866787f2ae33020dbe8e77/?name=Workshop:+Demand-Driven+Schema+Design)
- [Apollo GraphQL — Demand Oriented Schema Design](https://www.apollographql.com/docs/graphos/schema-design/guides/demand-oriented-schema-design)
- [Apollo GraphQL — Enterprise Best Practices: Schema Design](https://www.apollographql.com/tutorials/schema-design-best-practices)
- [Apollo GraphQL — 10 Best Practices for Schema Stewardship (Part 1)](https://www.apollographql.com/blog/10-best-practices-for-schema-stewardship)
- [Apollo GraphQL — 10 Best Practices for Schema Stewardship (Part 2)](https://www.apollographql.com/blog/community/graphql-champions/10-best-practices-for-schema-stewardship-part-2-of-2/)
- [Apollo GraphQL — Schema Basics](https://www.apollographql.com/docs/apollo-server/schema/schema)
- [GraphQL.org — Best Practices](https://graphql.org/learn/best-practices/)
- [Yelp — GraphQL Schema Design Guidelines](https://yelp.github.io/graphql-guidelines/schema-design.html)
- [Yelp — Nullability Guidelines](https://yelp.github.io/graphql-guidelines/nullability.html)
